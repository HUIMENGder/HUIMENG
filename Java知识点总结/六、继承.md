## 继承  
### 访问权限  
Java中有三种访问权限的修饰符：private，protect，public，如果不加修饰字符，表示包级可见。  
可以对类或者类中的成员变量加上访问修饰符。  
* 类可见表示其他类可以用这个类创建实例化对象  
* 成员可见表示其他类可以通过这个类的实例化对象来访问到该成员。

良好的设计模块会隐藏所有的实现细节，它把API和类的实现清晰的隔离开来，模块之前只通过API之间联系，一个模块不需要知道其他模块的内部工作情况。这个概念被称之为信息的隐藏或者封装，因此访问权限应该尽量使得每个类或者成员不被外界访问，   

如果⼦类的⽅法重写了⽗类的⽅法，那么⼦类中该⽅法的访问级别不允许低于⽗类的访问级别。  

字段绝不能是共有的，因为这么做会失去对这个字段修改行为的控制，客户端可以随意的修改。  
### 抽象类与接口  
#### 1.抽象类  
抽象类和抽象方法都是用abstract关键字来声明，如果一个类包含了抽象方法，那么这个类必须被声明成为抽象类。  

抽象类和普通类最大的区别在于：普通类可以被实例化，抽象类不可以被实例化，只能被继承。  
***实现：***  
```java
修饰符列表 abstract class 类名{ 
	类体=成员变量+方法+抽象方法;
}
```

#### 2.接口 
接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
 
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。  

接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。  
**实现：**
```java
修饰符列表 [abstract] class subclass [extends superclass] implements 接口名｛
	//非抽象类需要实现接口的全部抽象方法
	//若要实现接口中的抽象方法，需要在修饰符列表加上 public 关键字
	//无指定接口则默认接口为java.lang.Object
｝
```

**接口特性** :
* 接口的每一个方法也是隐式抽象的，接口的每一个方法被隐式的指定为public abstract   
* 接口中可以含有变量 ，但是接口中变量会被隐式的指定为public static final
* 接口中的方法是不能在接口中实现的，只能由接口的类进行实现接口的方法。
* 接口的实现使用关键字implements。  
***..implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...***
  
#### 3.抽象类和接口的区别  
* 抽象类的方法可以有方法体，就是能实现方法的具体功能，但是接口中的不行。
* 抽象类的成员变量可以是各种类型的，但是接口中的只能是public static final。
* 接口中不能含有静态代码块以及静态方法(static实现)，但是抽线类中是可以有的。
* 一个类只能继承一个抽象类，但是可以实现多个接口。  
*  ***注：JDK 1.8 以后，接口里可以有静态方法和方法体了。***  
***注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。***  
***注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法。***  
#### 4.选择使用  
##### 使用接口  
* 需要让不相关的类都实现一个方法，
* 需要使用多重继承 
##### 使用抽象类  
* 需要在几个相关的类共享代码  
* 需要能控制继承来的成员的访问权限，而不是都是public
* 需要继承非静态和非常量字段
### super  
* 访问父类的构造函数：可以使用super()函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是父类的默认的构造函数，如果子类需要调用父类的其他构造函数就需要调用super()函数。
* 访问父类的成员：如果子类重写了父类的某个方法，可以通过关键字super来引用父类的方法来实现。  
```java
public class SuperExample {
 protected int x;
 protected int y;
 public SuperExample(int x, int y) {
 this.x = x;
 this.y = y;
 }
 public void func() {
 System.out.println("SuperExample.func()");
 }
}
```
```  java
public class SuperExtendExample extends SuperExample {
 private int z;
 public SuperExtendExample(int x, int y, int z) {
 super(x, y);
 this.z = z;
 }
 public void func() {
 super.func();
 System.out.println("SuperExtendExample.func()");
 }
}
```
```java
SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
```  
### 重写与重载  
#### 1.重写  
存在于继承体系中，指子类实现了一个与父类在方法声明完全相同的一个方法。  
为了满足里是替换原则，重写要满足三个限制：
* 子类方法的访问权限必须大于等于父类的访问权限  
* 子类方法的返回值必须是父类方法的返回值或者子类；
* ⼦类⽅法抛出的异常类型必须是⽗类抛出异常类型或为其⼦类型。  
#### 2.实现多态是函数调用顺序  
&emsp;在调⽤⼀个⽅法时，先从本类中查找看是否有对应的⽅法，如果没有再到⽗类中查看，看是否从⽗类继承来。否则就要对参数进⾏转型，转成⽗类之后看是否有对应的⽅法。总的来说，⽅法调⽤的优先级为：  
* this.func(this)
* super.func(this)
* this.func(super)
* super.func(super)
#### 3.重载  
 存在于同一个类中，指一个方法已经与另一个方法名称相同，但是参数顺序，个数，类型至少有一个不同。  
 但是返回值不同，其他都相同的不是重载。  
 ``` java 
 class OverloadingExample {
 public void show(int x) {
 System.out.println(x);
 }
 public void show(int x, String y) {
 System.out.println(x + " " + y);
 }
}
```  