####深度优先搜索和广度优先搜索被广泛应用与数和图中。
### DFS(深度优先搜索)
&emsp;深度优先搜索会在得到一个新的节点后立即对新的节点进行遍历，（而不是像广度搜索一样用队列存储起来）如此反复遍历新的节点，直到没有新的节点了，此时返回。  
&emsp;从一个节点出发，使用DFS对一个图进行遍历时，能够遍历到的节点都是从初始节点可以达到的，故DFS常用来解决可达性问题。

**在程序实现DFS时要注意以下问题：**  
* 栈:用来保存当前节点的信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。  
* 标记：和BFS一样要对遍历过的节点进行标记

### DFS LeetCode例题
#### 一、[695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)
**题目描述：给定一个只包含0和1的二维数组，求能够在水平竖直四个方向连通的1的个数的最大值。**
```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int ans = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length; j ++){//双重for循环，对每一个节点都进行DFS
                ans = Math.max (ans , dfs(grid, i, j));//求解ans的最大值
            }
        }
        return ans;
    }
    public int dfs(int[][] grid, int p , int q){
        if(p < 0 || p == grid.length || q < 0 || q == grid[0].length || grid[p][q] == 0){
            return 0;//当前下标越界或者遇到的值为0时，停止递归，直接返回0
        }
        grid[p][q] = 0;//将访问过的数值置为0，防止重复遍历
        int ans = 1;//此时开始的数据就为1，故ans要从1开始
        ans += dfs(grid, p + 1, q);
        ans += dfs(grid, p - 1, q);
        ans += dfs(grid, p, q + 1);
        ans += dfs(grid, p, q - 1);//对四个方向分别进行深度优先搜索，并且求和即为从当前起点开始的最大面积
        return ans;
    }
}
```
**时间复杂度：O(R×C)。其中 RR 是给定网格中的行数，CC 是列数。我们访问每个网格最多一次。**  
**空间负载度：O(RxC)O(R×C)，递归的深度最大可能是整个网格的大小，因此最大可能使用 O(RxC)O(R×C) 的栈空间。**