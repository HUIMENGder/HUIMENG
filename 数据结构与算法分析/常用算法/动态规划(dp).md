### 动态规划(dp)
&emsp;动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 关于动态规划最经典的问题当属背包问题。  
&emsp;递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

**程序实现dp时要主要：**  
* 划分：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段一定是有序的或者可排序的
* 确定状态和状态变量：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性
* 确定决策并写出状态转移方程：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程
* 边界条件：状态转移方程是一个递推式，因此需要找到递推终止的条件  
### DP LeetCode例题
#### 字符串编辑问题
##### 一、[两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)
**题目描述：**
```java
//为了求得最少删除次数，我们可以求出串 s1s1 和串 s2s2 最长公共子序列，我们记为 lcslcs。如果我们能求得 lcslcs 的值，我们可以轻易地求出答案，为 m + n - 2*lcsm+n−2∗lcs。这里 mm 和 nn 分别是给定字符串 s1s1 和 s2s2 的长度。
class Solution {
    public int minDistance(String word1, String word2) {
        return word1.length() + word2.length() - 2 * lcs(word1, word2, word1.length(), word2.length());
    }
    public int  lcs (String s1, String s2, int m, int n){
        if(m == 0 || n == 0){//如果任意一个字符串的个数减为0，直接返回结束递归
            return 0;
        }
        /**
        为了找到最长公共子序列，使用递归lsc(s1, s2, m, n),为了求这个函数的值，先比较s1[m - 1]与
        s2[n - 1]位置的数据，如果相等，则公共子序列大小加一，如果两个字符串的最后一个字符不相等，我们有两种选择，一种  是比较 s1s1 倒数第二个字符与 s2s2 最后一个字符是否相等， 另一种选择是比较 s2s2 倒数第二个字符与 s1s1 最后一个字符是否相等。我们取两者中的较大值为当前函数的结果。
         */
        if(s1.charAt(m - 1) == s2.charAt(n - 1)){//
            return 1 + lcs(s1, s2, m - 1, n -1);
        }else{
            return Math.max(lcs(s1, s2, m - 1, n ),lcs(s1, s2, m, n -1));
        }
    }
}
```
**时间复杂度**